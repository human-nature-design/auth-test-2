# Architecture and Implementation Notes for `/todo-3`

This document walks through the architecture, auth flow, and deployment setup for the `/todo-3` experience. It follows the same structure I used in the video walkthrough: start with the stack, dive into authentication and multi-tenancy, then trace how the UI, actions, and database policies fit together. Rather than summarising, I want to leave all of the key beats intact so you can cross-reference them with the repo and replicate the setup end to end.

## 1. High-level tour of the stack

The UI is a Next.js 15 app written in React 19 with Tailwind classes generated by Subframe’s design system. You can see those dependencies declared in `package.json`, alongside the Supabase client libraries that power auth and data access.【F:package.json†L1-L28】 Subframe is doing the heavy lifting for component markup and variants—for example, both the checkbox and destructive icon button used in the todo list map directly to Subframe components exported from the `@subframe/core` package.【F:src/ui/components/Checkbox.tsx†L1-L60】【F:src/ui/components/IconButton.tsx†L1-L130】

On the backend side there is no custom server; the app relies entirely on Supabase for the Postgres database, authentication, and row level security (RLS). The client and server helpers created via `@supabase/ssr` handle session cookies automatically so each request has the user context it needs.【F:src/utils/supabase/client.ts†L1-L8】【F:src/utils/supabase/server.ts†L1-L27】

## 2. How authentication wraps the app

Two layers keep unauthenticated users out of the protected routes. First, the top-level middleware delegates to a Supabase-aware helper that refreshes sessions on every request and short-circuits visitors who are not logged in. The middleware matcher covers every non-static path so the check consistently runs server-side.【F:src/middleware.ts†L1-L17】 The heavy lifting happens inside `updateSession`: it constructs a Supabase server client, pulls the session cookie from the request, checks if there is a logged-in user, and redirects unauthenticated traffic back to the landing page unless the path is explicitly marked public.【F:src/utils/supabase/middleware.ts†L1-L48】

Second, the `(protected)` route group wraps every page under `/todo-*` in a layout that re-validates the session before rendering. If the user lookup fails, the layout issues a `redirect('/')`, giving you a client-side safety net in addition to the server middleware.【F:src/app/(protected)/layout.tsx†L1-L19】 Together, those two guards mimic the “full wrapper” described in the video: server-side redirects handle the common case, while the layout prevents an end user from loading protected components even if they managed to bypass the middleware cache.

## 3. Logging in and issuing the session cookie

The public landing page renders a login/sign-up form. When a returning user submits their credentials, `supabase.auth.signInWithPassword` runs in the browser and, on success, Next’s router pushes them to `/todo-3` and refreshes the client so server components pick up the new session cookie.【F:src/app/page.tsx†L1-L19】【F:src/components/login-form.tsx†L1-L129】 Supabase stores the JWT-backed session in an HTTP-only cookie. Because both the middleware and the server helpers read from `request.cookies`, subsequent requests—including the server component render for `/todo-3`—automatically receive the authenticated context.【F:src/utils/supabase/middleware.ts†L8-L33】【F:src/utils/supabase/server.ts†L7-L24】

## 4. Server actions mirror CRUD permissions

All of the data access for `/todo-3` lives in `actions.ts`. Each exported function starts by rehydrating the Supabase server client and verifying the user identity. That identity check is important; the Supabase helpers run on the server, so you can throw an “Unauthorized” error before hitting the database if there is no session.【F:src/app/(protected)/todo-3/actions.ts†L12-L76】 Once the user is confirmed, the actions map 1:1 to Postgres operations:

- `getTodos` selects the todo records for the authenticated user, ordering by descending id so new entries appear first.
- `addTodo` inserts a new row tied to the current `user_id` and returns the created record.
- `deleteTodo` filters by both `id` and `user_id` so a malicious user cannot delete someone else’s tasks even if they know an id.
- `completeTodo` updates the `is_complete` flag and returns the updated row, again double-checking both `id` and `user_id`.

This mirrors the CRUD policy configuration in Supabase’s Quickstart. The project README contains the exact SQL enabling RLS and restricting every insert, select, update, and delete to `auth.uid() = user_id`, which is why the optimistic UI can rely on server-side enforcement for multi-tenancy.【F:README.md†L62-L113】

## 5. Page orchestration and data loading

The `/todo-3` page itself is a server component. It awaits `getTodos()`, passes those results to the client component, and renders a logout button underneath the list.【F:src/app/(protected)/todo-3/page.tsx†L1-L16】 Because the data fetch happens server-side, the first paint already shows the user’s todos—the list is not blank while waiting for a client fetch. Logging out simply calls `supabase.auth.signOut()` and pushes the user back to `/`, which clears the cookie and, thanks to the middleware, immediately blocks access to the protected routes.【F:src/components/logout-button.tsx†L1-L24】

## 6. Client component structure and optimistic UI

`TodoListClient` is the client component that controls interactivity. It seeds local state with the server-provided array so the UI is hydrated immediately, then keeps that state in sync with server actions. There are three handlers—add, delete, and complete—that all implement a small optimistic workflow: update local state first, call the server action, and roll back plus surface an alert if the request fails.【F:src/app/(protected)/todo-3/Todo-component.tsx†L10-L118】 The add flow also enforces the same minimum length constraint (`> 3` characters) as the database policy before it ever hits Supabase, which keeps the UI aligned with RLS validation.【F:src/app/(protected)/todo-3/Todo-component.tsx†L15-L26】【F:README.md†L79-L92】

Rendering the list is straightforward: the component maps each todo into a row containing the Subframe checkbox, the task id for quick debugging, and a destructive secondary icon button wired to the delete action. Those variants (“destructive-secondary”, small size) match the design tokens defined by Subframe, so tweaking the visual style in the design tool flows directly into the generated React component.【F:src/app/(protected)/todo-3/Todo-component.tsx†L93-L115】【F:src/ui/components/IconButton.tsx†L15-L123】

## 7. Understanding multi-tenancy with RLS

With Supabase row level security enabled, every query runs inside the context of the authenticated user’s JWT. The Postgres policies check that `auth.uid()` matches the `user_id` column, which means even if a user tried to handcraft a request targeting another id, the database simply would not return or mutate those rows.【F:README.md†L62-L113】 That enforcement, paired with the redundant `.eq("user_id", user.id)` filter in the actions, is what delivers the “I can only see my todos” experience you can observe in the dashboard or the UI.

## 8. Design system workflow with Subframe + Tailwind

Subframe acts as the design surface for the project. Each component exported into the repo carries Tailwind utility classes wired to Subframe’s variants. For example, the icon button exposes brand, neutral, and destructive variants, while the checkbox includes aria state styling and a `FeatherCheck` icon out of the box.【F:src/ui/components/IconButton.tsx†L15-L123】【F:src/ui/components/Checkbox.tsx†L33-L55】 When you tweak a property (like switching to the `destructive-secondary` style) inside Subframe, the generated React component keeps the class names in sync, so there is no gap between the visual design system and the code you ship.

## 9. Environment variables and Supabase connectivity

Both the browser and server Supabase helpers rely on the same publishable credentials: `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY`. Because they are public keys, they are safe to expose in the client bundle. The sensitive service-role key never leaves Supabase; all privileged work happens via authenticated end-user sessions. The helpers wire those keys into `createBrowserClient` and `createServerClient`, ensuring every part of the app reads the same project configuration.【F:src/utils/supabase/client.ts†L1-L8】【F:src/utils/supabase/server.ts†L7-L24】

## 10. Continuous deployment with Vercel + Supabase previews

The repo lives on GitHub and deploys through Vercel. The README outlines the “Deploy with Vercel” flow, which scaffolds a Supabase project, injects the right environment variables, and spins up branch-based preview environments. Each branch gets its own Supabase instance, so you can validate migrations or policy tweaks safely before merging into main.【F:README.md†L15-L61】 Once the preview build succeeds, you can smoke test the hosted app; because the previews reuse the same Supabase policies and keys, creating or deleting a todo in the deployed build shows up locally as well.

## 11. Putting it all together

From login to logout, the request path looks like this:

1. **Visit `/`** → middleware calls `updateSession`, sees no user, and allows the request because `/` is public.【F:src/middleware.ts†L9-L17】【F:src/utils/supabase/middleware.ts†L31-L48】
2. **Submit credentials** → Supabase sets the session cookie and Next redirects to `/todo-3`.【F:src/components/login-form.tsx†L17-L34】
3. **Middleware runs again** → now the cookie resolves to a user, so the request proceeds, `getTodos()` runs server-side, and the page hydrates with the user’s rows.【F:src/app/(protected)/todo-3/page.tsx†L1-L16】【F:src/app/(protected)/todo-3/actions.ts†L12-L29】
4. **UI interactions** → client handlers optimistically update state while server actions enforce RLS-backed CRUD access.【F:src/app/(protected)/todo-3/Todo-component.tsx†L15-L115】【F:README.md†L62-L113】
5. **Log out** → `signOut()` clears the session cookie, redirecting the user back to `/` and once again locking down the protected route group.【F:src/components/logout-button.tsx†L10-L22】【F:src/app/(protected)/layout.tsx†L1-L19】

Nothing here relies on hidden state or manual session management; everything flows through Supabase’s JWT cookie, Next.js middleware, and Subframe-generated components. If you follow the same steps—provision a Supabase project, enable the todo RLS policies, and wire the environment variables—you’ll end up with the same multi-tenant, design-system-driven CRUD experience demonstrated in the video.
